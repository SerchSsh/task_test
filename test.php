<?php

/*
    1. Написать функцию, которая на входе принимает строку из скобок, и возвращает true
    если все открытые скобки закрыты, иначе - false. Возможные варианты скобок: ()[]{}
    Пример:
    "(){}[]" => true
    "([{}])" => true
    "(}" => false
    "[(])" => false
    "[({})](]" => false
*/

/**
 * Функция проверяет все ли скобки во входной строке, корректно закрыты.
 *
 * Алгоритм функции следующий: будем сохранять каждую открывающую скобку в стеке, а закрывающую проверять. 
 * Если последняя открывающая скобка в стеке соответствует текущей закрывающей скобке, тогда удалим скобку из стека.
 * Иначе можно сказать, что последовательность некорректна.
 * Если цикл прошелся по всей строке, тогда проверим стек. Если он пуст - то последовательность корректна, иначе - нет. 
 *
 * @param [type] $str - строка состоящая из скобок.
 * @return bool - True - если последовательность из скобок корректна, False - если последовательность из скобок не корректна.
 */
function check(string $str): bool {
    if ($str == '') {
        return false;
    }

    $stack = [];
    // Храним соответствие между скобками.
    $map = [
        '(' => ')',
        '[' => ']',
        '{' => '}',
    ];

    for ($i = 0; $i < strlen($str); $i++) {
        if (strpos('([{', $str[$i]) !== false) {
            $stack[] = $str[$i];
            continue;
        }

        $char = array_pop($stack);
        // Если стек пустой, в $char будет null, поэтому проверим, так же, что $char не null.
        if (!$char || $map[$char] != $str[$i]) {
            return false;
        }
    }

    return boolval(!count($stack));
}

/*
    3. Написать функцию, которая принимает в качестве аргументов число (количество
    строк в итоговом массиве) и символ (для заполнения массива, см. пример), возвращает
    массив строк.
    Пример:
    build(6, "*");
    Вернет массив:
    [
    ' * ',
    ' *** ',
    ' ***** ',
    ' ******* ',
    ' ********* ',
    '***********',
    ]
*/

/*

Написать SQL запрос. Есть таблицы authors и books. Нужно вывести из них данные
по авторам, количеству книг и наличию положительного рейтинга у книг. Формат
вывода: имя автора, общее количество книг данного автора, признак наличия книг с
положительным рейтингом (если rating более 4.0, то выводить 1, иначе - 0). Результаты
нужно отсортировать по количеству в обратном порядке. Дополнительно вывести
только те, у которых количество книг с положительным рейтингом более 1. Схемы:

CREATE TABLE `authors` (
`id` int NOT NULL AUTO_INCREMENT,
`name` varchar(255),
PRIMARY KEY (`id`)
);

CREATE TABLE `books` (
`id` int NOT NULL AUTO_INCREMENT,
`title` varchar(255),
`year` int,
`author_id` int,
`rating` decimal(3, 1),
PRIMARY KEY (`id`),
FOREIGN KEY (author_id)
REFERENCES authors(id)
);
*/

/**
 * Запрос вернет имя автора, общее количество книг данного автора, признак наличия книг с положительным рейтингом.
 * Обратить внимание можно на конструкцию SIGN(SUM(CASE WHEN rating>=4 THEN 1 ELSE 0 END)) - суммируем положительные рейтинги, для авторов (согласно ТЗ).
 * Дальше можно было использовать еще один CASE, но проще и локаничнее использовать SIGN, которая вернет 0 для 0, и 1 для любого положительного числа. Также -1 для отрицательных чисел, но в данном случае это не важно.
 * В остальном запрос не сложный.
 * 
 * SELECT a.name, COUNT(author_id) as counts, SIGN(SUM(CASE WHEN rating>=4 THEN 1 ELSE 0 END)) rating FROM `books`, `authors` a WHERE a.id = author_id GROUP BY author_id ORDER BY counts DESC
 * 
 * 
 * Запрос вернет только те, у которых количество книг с положительным рейтингом более 1.
 * В отличии от предыдущего запроса, тут покажем кол-во книг с рейтингом более 1, не будем сводить рейтинг с помощью SIGN. И наложим условие на группу, фильтруя рейтинги с суммой больше 1, согласно ТЗ.
 * 
 * SELECT a.name, COUNT(author_id) as counts, SUM(CASE WHEN rating>=4 THEN 1 ELSE 0 END)  as ratings FROM `books`, `authors` a WHERE a.id = author_id GROUP BY author_id HAVING ( ratings > 1 ) ORDER BY counts DESC
 *
 */

/**
 * Функция возвращает массив из N строк, распечатав который последовательно, получим равнобедренный треугольник состоящий из символа-заполнителя. 
 * Если входные параметры не корректны - вернет пустой массив.
 * 
 * Алгоритм работы: легко заметить, что длина строк будет 2N-1. Зная это, можем запустить, цикл для формирования строк.
 * Будем формировать строки из пробелов, вставляя в центр строку из символов-заполнителей.
 * На каждой итерации внешнего цикла, будет формироваться меньше строка из пробелов, и больше строка из символа-заполнителя.
 *
 * @param integer $n - число строк.
 * @param string $ch - символ-заполнитель.
 * @return array - массив с результатом.
 */
function build(int $n, string $ch): array {
    if ($n < 1 || $ch == '') {
        return [];
    }
    
    $output = [];
    $tmpStr = $ch;
    for ($i = 0; $i < $n; $i++) {
        $spaceStr = '';
        for ($j = 1; $j < $n - $i; $j++) {
            $spaceStr .= ' ';
        }
        $output[] = $spaceStr . $tmpStr . $spaceStr;
        $tmpStr = $ch . $tmpStr . $ch;
    }
    return $output;
}